# Вопросы

1. shift/reduce и reduce/reduce конфликты
2. куда отправляется бит(байт?) при каждом конфликте, [reduce на верх стека, при шифте ждет следующий бит]

## 1. **Shift/Reduce конфликт**

Ситуация: парсер может либо **считать следующий токен (shift)**, либо **свернуть правило (reduce)**, и не знает, что выбрать.

Классический пример — выражения без приоритетов:

### Пример грамматики (выражения)

```
%token NUM
%%
expr:
      expr '+' expr
    | NUM
;
```

Если вход:

```
1 + 2 + 3
```

В момент обработки второго `+`, парсер видит состояние:

* можно свернуть `expr '+' expr` → `expr`
* можно сделать shift и считать следующий `+`

bison сообщит:

```
shift/reduce conflict
```

Решение: ввести приоритеты или левую/правую ассоциативность.

## 2. **Reduce/Reduce конфликт**

Ситуация: парсер может **свернуть по двум разным правилам**, но не знает, какое из них выбрать.

Минимальный пример:

### Пример грамматики

```
%token ID
%%
stmt:
      id_or_num
    ;

id_or_num:
      ID
    | ID   /* второе правило совпадает по правой части */
;
```

Здесь два правила полностью одинаковы. bison не знает, какое правило применять и выдает:

```
reduce/reduce conflict
```

Более практичный пример — список, где два разных нетерминала могут сворачиваться на один и тот же токен:

### Пример

```
%token ID NUM
%%

value:
      ID
    | NUM
;

item:
      ID
    | NUM
;

start:
      value
    | item
;
```

Если вход `ID`, и текущий символ допускает сворачивание и в `value`, и в `item`, возникает конфликт reduce/reduce.

## Краткое резюме

**Shift/Reduce**
Парсер не знает, продолжать разбор или уже сворачивать правило.
Типичный источник: операторы без приоритетов.

**Reduce/Reduce**
Парсер не знает, по какому из нескольких правил сворачивать.
Типичный источник: разные нетерминалы, имеющие одинаковые правые части.


# 1. Действия Bison при **shift/reduce** конфликте

Конфликт shift/reduce возникает, когда в некотором состоянии LR-автомата Bison имеет два возможных действия:

1. выполнить **shift** (прочитать следующий токен и поместить его в стек),
2. выполнить **reduce** (применить правило и свернуть цепочку символов).

При появлении конфликта Bison действует по фиксированным правилам:

## 1.1. Если указаны приоритеты и ассоциативность

Bison сравнивает:

• приоритет токена на входе,
• приоритет правила, которое конфликтует с shift.

Решение:

• если приоритет токена > приоритет правила → выполняется **shift**;
• если приоритет правила > приоритет токена → выполняется **reduce**;
• если приоритет равен, используется ассоциативность:

* left — выполняется **reduce**,
* right — выполняется **shift**,
* nonassoc — ошибка (запрещено иметь такие конструкции).

## 1.2. Если приоритеты не заданы

Bison использует правило по умолчанию:

**Всегда выбирает shift.**

Это приводит к более предсказуемому чтению входа, но иногда делает разбор недетерминированным.

Bison при этом:

• сообщает warning: `shift/reduce conflict`,
• печатает количество конфликтов в отчете (`.output`).

---

# 2. Действия Bison при **reduce/reduce** конфликте

Reduce/reduce конфликт возникает, когда Bison должен выбрать между **двумя разными правилами** для свёртки, и нет причины предпочесть одно другому.

## 2.1. Если приоритеты не заданы

Bison использует простое правило:

**Выбирается первое объявленное правило (по порядку в грамматике).**

Второе потенциальное правило становится недостижимым в этом состоянии.

Bison:

• сообщает warning `reduce/reduce conflict`,
• индицирует конфликт в `.output`.

## 2.2. Если приоритеты заданы

Приоритеты могут разрешить reduce/reduce конфликт:

• Bison сравнивает приоритеты двух правил
• правило с более высоким приоритетом выигрывает.

Если приоритеты совпадают → используется первое объявленное правило.

# 3. Что именно делает Bison в плане внутреннего поведения

### 3.1. Стековая операция при shift/reduce

При выборе **shift**:

• токен считывается,
• помещается в стек,
• переход выполняется в новое состояние.

При выборе **reduce**:

• Bison снимает из стека N символов (длина правой части правила),
• вычисляет семантическое значение через `{ ... }`,
• переходит по goto в новое состояние,
• кладёт новый нетерминал.

### 3.2. Внутренний результат конфликта

Bison не "пробует оба пути". Он выбирает **одно конкретное действие**.

Это означает:

• часть потенциальных деревьев теряется,
• разбор становится жёстко детерминированным,
• возможны ошибки разбора при расширении языка.

# 1. Задание приоритета операторам

Интерпретация:

• `+` и `-` имеют самый низкий приоритет (первая строка),
• `*` и `/` — выше (вторая строка),
• `^` — самый высокий (третья строка),
• `%right` задаёт **правую ассоциативность**, `%left` — левую, `%nonassoc` — отсутствие ассоциативности.

# 2. Приоритет правила

Каждое правило по умолчанию получает приоритет:

• равный приоритету **последнего терминала в правой части**,
• либо **нет приоритета**, если терминалов нет.
